# Start a project

## Launch xsbt

Create a blank folder, create project folders, cd into it and start `xsbt`.  Example:

    cd ..;rm -rf scalaProj1/; mkdir -p scalaProj1/src/main/resources scalaProj1/src/main/scala scalaProj1/src/test/resources scalaProj1/src/test/scala scalaProj1/project/build; cd scalaProj1/; xsbt

## Create beginning files

From a text editor *OTHER* than IntelliJ, create a project file
`project/build/Project.scala` with the following contents:

    import sbt._ 
    class Project(info: ProjectInfo) extends DefaultProject(info) {}  

## Start Coding

Turn on *Triggered Execution* in sbt to watch for code changes that it will then automatically compile.

    > ~ watch-sources

## Create new scala object 

Create new scala object `HelloWorld` in
`Tutorial1/src/main/scala/HelloWorld.scala`

    object HelloWorld {
      def main(args: Array[String]){
        println(hello)
      } 
      def hello:String = {
        return "Hello World!";
      }
    }  

The argument of the scala command has to be a top-level object. If
that object is followed by the clause extends Application, then all
statements contained in that object will be executed; otherwise you
have to add a method main which will act as the entry point of your
program.  Here is how an object that extends Application looks like
(note this is just an FYI don't put it in your scala file yet):

    object HelloWorld2 extends Application {
      println("Hello, world!")
    }

## Run it

As you saved the above file you should have seen it get compiled.
Lets run it, open a terminal and go to your project directory and
type:

    $ cd target/scala-2.8.1.final/classes/
    $ scala HelloWorld
    Hello World!

## Add a class and use it

Create new scala class `Second` in
`Tutorial1/src/main/scala/Second.scala`

    class Second {
      def func1 = {
        return "Hello World!";
      }
    }  








## Scala Repl

To drop into a scala shell do:

    > console-project


## Log Levels

Temporarily change the logging level and configure how stack traces
are displayed by modifying the log-level or trace-level settings:

    > set logLevel := Level.Warn

Valid Level values are Debug, Info, Warn, Error.


# Emacs and Scala

[ref](http://thegreylensmansview.blogspot.com/2009/02/stone-tools-and-scala-development-part.html)

# Reference:

* [First Steps](http://www.artima.com/pins1ed/first-steps-in-scala.html)
* [First Steps](http://www.artima.com/scalazine/articles/steps.html)
* [Eclipse and Scala](http://www.vogella.de/articles/Scala/article.HTML)

Here are some *Learning Scala* references:

* [O'Reilley Book: Programming Scala](http://ofps.oreilly.com/titles/9780596155957/IntroducingScala.html)
* [List of Scala resources](http://www.scala-lang.org/node/1305)
* [Another good ONLINE scala reference by Martin Odersky](http://www.artima.com/pins1ed/)

# Installation

Simply untar and add [scala-home]/bin to your path.

## Running Scala

Create a class that looks like the following:

    package secondScala;
     
    object App extends Application {
      override def main(args : Array[String]) { println( "Hello World!" )}
    }

    mvn compile; cd target/classes; scala secondScala.App



# Misc

Setup sbt to publish to your maven repository: 

* [ref1](http://brizzled.clapper.org/id/100/)
* [ref2](http://code.google.com/p/simple-build-tool/wiki/Publishing)
* [ref3](https://github.com/harrah/xsbt/wiki/Publishing)
* [ref4](https://github.com/harrah/xsbt/wiki/Resolvers)
* [ref5](http://code.google.com/p/simple-build-tool/wiki/Publishing)
* [Build File Example](https://github.com/harrah/xsbt/wiki/Full-Configuration)

## setup

Setup xsbt first:

[ref](https://github.com/harrah/xsbt)

    git clone git://github.com/harrah/xsbt.git
    cd xsbt

setup latest android-plugin

    git clone https://github.com/jberkel/android-plugin.git 
    cd android-plugin 
    xsbt 
    update 
    publish-local 



[ref1](http://nevercertain.com/2011/02/03/scala-android-intellij-win-part-1-prerequisites.html)
[ref2](http://nevercertain.com/2011/02/03/scala-android-intellij-win-part-2-simple-build-tool.html)

    android-sdk-linux_x86/tools

    Click 'Available Packages'
    Expand 'Android Repository'
    Check the box that says 'Android SDK Tools, revision 7'
    Click 'Install Selected'
    Click 'Accept All' to accept all licenses
    Click 'Install'


# SCALA LANGUAGE REFERENCE

## Functions/Methods

    def: myFunc( argName: String ) {
       ...
    }

    def max(x: Int, y: Int): Int = if (x < y) y else x

max: (Int,Int)Int

Formula:

A Scala function definition looks like this:

    def [function-name] ([parameter-name]: [parameter-type]) : [return-type] = [function-body]
    
so

    def taste (food: Consumable) : Opinion = evaluate(food)

defines a function called `taste` that takes a `Consumable` as a
parameter named `food` and returns an `Opinion`. It calls `evaluate` and
returns the result, which must be an `Opinion`

The last value is returned - no explicit return is required, but since
the language is strongly typed there is protection against
accidentally returning meaningless values of the wrong type

## Function Literals

The syntax for a function literal is a list of named parameters, in
parentheses, a right arrow, and then the body of the function.

![Image depicting a function literal and its parts](images/functionLiteral60.jpg "The syntax of a function literal in Scala")

## Functions as Arguments

In the following code, the function oncePerSecond is defined with one
argument of type: `() => Unit`.  A function with *NO* arguments and
returns `Unit`.  Exactly what `timeFlies` is.
 
    object Timer {
      def oncePerSecond(callback: () => Unit) {
        while (true) { callback(); Thread sleep 1000 }
      }
      def timeFlies() {
        println("time flies like an arrow...")
      }
      def main(args: Array[String]) {
        oncePerSecond(timeFlies)
      }
    }

## Unit (java: void)

scala.Unit, is Scala's analogue to void in Java. The main difference
between Scala's Unit and Java's void is that Scala lets you write down
a value of type Unit, namely (), whereas in Java there is no value of
type void.

## vals & vars

Scala differentiates between vals, variables that are assigned once
and never change, and vars, variables that may change over their
lifetime.

## Defining Variables/Values

[val|var] [variable name] : [type] = [value to assign]

    val name : java.lang.String = "Fenton Travers"

Type comes *AFTER* variable/value name.

## Static Methods

Static members (methods or ﬁelds) do not exist in Scala. Rather than
deﬁning static members, the Scala programmer declares these members in
singleton objects

    object HelloWorld {
      def main(args: Array[String]) {
        println("Hello, world!")
      }
    } 

# Data Structures

## Arrays

Access an element in an array by specifying an index in parentheses.

    // Say hello to the first argument
    println("Hello, "+ args(0) +"!")

# Misc

## Incrementing integers

Java's ++i and i++ don't work in Scala. To increment an integer in
Scala, you need to say either i = i + 1 or i += 1.


## Classes

One important difference is that classes in Scala can have parameters. This
is illustrated in the following deﬁnition of complex numbers.

    class Complex(real: Double, imaginary: Double) {
      def re() = real
      def im() = imaginary
    }

These arguments must be passed when creating an instance of class
Complex, as follows: 

    new Complex(1.5, 2.3). 

The class contains two methods, called re and im, which give access to
these two parts.



# Garbage

the rest below is preserved as it might be useful in the future:

List the different templates you can use with `giter8` aka: `g8`

    g8 --list

This one looks good for starting off:

    chrislewis/simple-scala-project         g8 template for a simple scala project

So run:

    g8 chrislewis/simple-scala-project

Accept the defaults.

[ref](https://github.com/mpeltonen/sbt-idea)

In your project created by giter8,


This will build a basic android app shell project:

    g8 jberkel/android-app

accept all defaults

    cd my-android-project/

## Build File Garbage

  override def managedStyle = ManagedStyle.Maven

  lazy val publishTo = Resolver.sftp("linux1", "linux1.hk.oracle.com", "/var/www/html/maven2")
 credentials += Credentials(Path.userHome / ".ivy2" / ".credentials")

object Resolvers {
  val sunrepo    = "Sun Maven2 Repo" at "http://download.java.net/maven/2"
  val sunrepoGF  = "Sun GF Maven2 Repo" at "http://download.java.net/maven/glassfish"
  val oraclerepo = "Oracle Maven2 Repo" at "http://download.oracle.com/maven"

  val oracleResolvers = Seq (sunrepo, sunrepoGF, oraclerepo)
}


# Lift Web Framework

## Ref

[Lift Framework](http://scalalift.com/)

## Intro

A simple example:

hidden-templates/fancy.html

    <html><body class="fancy">
        <lift:bind name="contents"/>
    </body><html>

fish/tropical.html

    <lift:surround with="hidden-templates/fancy" at="contents">
        Floating above tropical fish is like being in a colorful cartoonland.
    </lift:surround>

Results in:

    <html class="fancy"><body class="fancy">
        Floating above tropical fish is like being in a colorful cartoonland.
    </body></html>

You can also simply embed a template inside another one using the
*embed tag:

    <lift:embed what="hidden-templates/footer"/>

Second Pass Notes:

no extension is provided on the template name to allow flexibility for
localization suffixes, file types, etc.  hidden-templates is not
required in the path.  if only the filename (without extension) is
specified, the whole view path will be searched.


## Maven

    mvn org.apache.maven.plugins:maven-archetype-plugin:1.0-alpha-7:create -DarchetypeGroupId=org.scala-tools.archetypes -DarchetypeArtifactId=scala-archetype-simple -DarchetypeVersion=1.1 -DremoteRepositories=http://scala-tools.org/repo-releases -DgroupId=your.proj.gid -DartifactId=your-proj-id

I updated the scala version in the properties section like so:

    <scala.version>2.9.0-1</scala.version>



* Make the project suitable for importing into IntelliJ

    gen-idea

to make the project compatible with IDEA IntelliJ.  Don't worry about
the warnings.  They are just trying to download javadocs & sources for
the dependent libraries, not all of which have those items...thus the
warning messages.

Import it into IntelliJ.  Close any projects if you have one open.
Then do:

    File > Open Project

Navigate to your project folder, and click `OK`.
