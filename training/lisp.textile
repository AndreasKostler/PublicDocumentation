"home":/index.html > SLIME

p(toc). Table of Contents

{toc}

h1. Getting Started

In emacs execute:

bc. Alt-x slime

h1. Commands

h2. Printing

bc. (format t "hello, world")

Format directives start with ~ (much the way printf’s directives start
with %).

The ~t directive is for tabulating. The ~10t tells FORMAT to emit enough spaces to move to
the tenth column before processing the next ~a. A ~t doesn’t consume any arguments.

CL-USER>  (format t "~a:~10t~a" :artist "Dixie Chicks")
ARTIST:   Dixie Chicks
NIL

Now things get slightly more complicated. When FORMAT sees ~{ the next
argument to be consumed must be a list. FORMAT loops over that list,
processing the directives between the ~{ and ~}, consuming as many
elements of the list as needed each time through the list.

In dump-db, the FORMAT loop will consume one keyword and one value
from the list each time through the loop. The ~% directive doesn’t
consume any arguments but tells FORMAT to emit a newline. Then after
the ~} ends the loop, the last ~% tells FORMAT to emit one more
newline to put a blank line between each CD.

bc. 
(defun dump-db ()
 (dolist (cd *db*)
  (format t "~{~a:~10t~a~%~}~%" cd)))


You can also see the current value of @*db*@ whenever you want by typing @*db*@ at the REPL.

bc. 
CL-USER> *db*
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE"Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))

Technically, you could have also used FORMAT to loop over the database
itself, turning our dump-db function into a one-liner.

bc. 
(defun dump-db ()
(format t "~{~{~a:~10t~a~%~}~%~}" *db*))

h2. User Input

h3. Strings 

The variable *query-io* is a global variable (which you can tell
because of the * naming convention for global variables) that contains
the input stream connected to the terminal.

bc. 
(defun prompt-read (prompt)
 (format *query-io* "~a: " prompt)
 (force-output *query-io*)
 (read-line *query-io*))

Note that there’s no ~% in the format string, so the cursor will stay
on the same line. The call to FORCE-OUTPUT is necessary in some
implementations to ensure that Lisp doesn’t wait for a newline before
it prints the prompt.

Then you can read a single line of text with the aptly named READ-LINE
function.

h3. Integers

prompt-read returns a string, what about numbers/booleans?

bc. (parse-integer (prompt-read "Age"))

Unfortunately, the default behavior of PARSE-INTEGER is to signal an
error if it can’t parse an integer out of the string or if there’s any
non-numeric junk in the string. However, it takes an optional keyword
argument :junk-allowed, which tells it to relax a bit.

bc. (parse-integer (prompt-read "Rating") :junk-allowed t)

But there’s still one problem: if it can’t find an integer amidst all
the junk, PARSE-INTEGER will return NIL rather than a number. In
keeping with the quick-and-dirty approach, you may just want to call
that 0 and continue. Lisp’s OR macro is just the thing you need
here. It’s similar to the “short-circuiting” || in Perl, Python, Java,
and C; it takes a series of expressions, evalu- ates them one at a
time, and returns the first non-nil value (or NIL if they’re all
NIL). So you can use the following:

bc. (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)

h3. Booleans

Fixing the code to prompt for Ripped is quite a bit simpler. You can just use the Common
Lisp function Y-OR-N-P.

bc. (y-or-n-p "Ripped [y/n]: ")

Putting it all together:

bc. 
(defun prompt-for-cd ()
 (make-cd
 (prompt-read "Title")
 (prompt-read "Artist")
 (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
 (y-or-n-p "Ripped [y/n]: ")))


h2. Other Commands

* Define a new function

bc. (defun <function_name> <paren_list> <function>)

* Define a variable (with DEFVAR macro)

bc. (defvar *data* nil)

* DOLIST macro.  This function works by looping over all the elements of *db* with the DOLIST macro,
binding each element to the variable cd in turn. For each value of cd, you use the FORMAT
function to print it.

bc. 
(defun dump-db ()
 (dolist (cd *db*)
  (format t "~{~a:~10t~a~%~}~%" cd)))


* Loading a file full of lisp

bc. (load "myFunctions.lisp")

* Load defun into lisp (do anywhere in or immediately after defun)

bc. C-c C-c

* Switch to the REPL

bc. C-c C-z

* Quit

bc. , quit

* Exit the debugger

bc. q

* Compile a file, creates "hello.fasl" (FASt Load)

bc. (compile-file "hello.lisp")

* Compile and load the file in the current buffer

bc. C-c C-k

* Make a list function, constructs a list from its arguments

bc. (list 1 2 3)
(1 2 3)

* A plist or property list (like a hash map) contains key=>value pairs. A plist is a list where every other element, starting with the first, is a symbol that describes what the next element in the list is. A keyword is any name that starts with a colon (:), for instance, :foo. 

bc. (list :a 1 :b 2 :c 3)

* The function GETF, which takes a plist and a symbol and returns the value in the plist following the symbol

bc. (GETF (list :a 1 :b 2 :c 3) :a)
(1)
