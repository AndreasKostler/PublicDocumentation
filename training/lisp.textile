"home":/index.html > SLIME

p(toc). Table of Contents

{toc}

h1. Getting Started

In emacs execute:

bc. Alt-x slime

h1. Commands

h2. Printing

bc. (format t "hello, world")

Format directives start with ~ (much the way printf’s directives start
with %).

The ~t directive is for tabulating. The ~10t tells FORMAT to emit enough spaces to move to
the tenth column before processing the next ~a. A ~t doesn’t consume any arguments.

CL-USER>  (format t "~a:~10t~a" :artist "Dixie Chicks")
ARTIST:   Dixie Chicks
NIL

Now things get slightly more complicated. When FORMAT sees ~{ the next
argument to be consumed must be a list. FORMAT loops over that list,
processing the directives between the ~{ and ~}, consuming as many
elements of the list as needed each time through the list.

In dump-db, the FORMAT loop will consume one keyword and one value
from the list each time through the loop. The ~% directive doesn’t
consume any arguments but tells FORMAT to emit a newline. Then after
the ~} ends the loop, the last ~% tells FORMAT to emit one more
newline to put a blank line between each CD.

bc. 
(defun dump-db ()
 (dolist (cd *db*)
  (format t "~{~a:~10t~a~%~}~%" cd)))


You can also see the current value of @*db*@ whenever you want by typing @*db*@ at the REPL.

bc. 
CL-USER> *db*
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE"Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))

Technically, you could have also used FORMAT to loop over the database
itself, turning our dump-db function into a one-liner.

bc. 
(defun dump-db ()
(format t "~{~{~a:~10t~a~%~}~%~}" *db*))

h2. User Input

h3. Streams

h4. Out

t is shorthand for the stream *standard-output*

h4. In

The variable *query-io* is a global variable (which you can tell
because of the * naming convention for global variables) that contains
the input stream connected to the terminal.


h3. Strings 

The variable *query-io* is a global variable (which you can tell
because of the * naming convention for global variables) that contains
the input stream connected to the terminal.

bc. 
(defun prompt-read (prompt)
 (format *query-io* "~a: " prompt)
 (force-output *query-io*)
 (read-line *query-io*))

Note that there’s no ~% in the format string, so the cursor will stay
on the same line. The call to FORCE-OUTPUT is necessary in some
implementations to ensure that Lisp doesn’t wait for a newline before
it prints the prompt.

Then you can read a single line of text with the aptly named READ-LINE
function.

h3. Integers

prompt-read returns a string, what about numbers/booleans?

bc. (parse-integer (prompt-read "Age"))

Unfortunately, the default behavior of PARSE-INTEGER is to signal an
error if it can’t parse an integer out of the string or if there’s any
non-numeric junk in the string. However, it takes an optional keyword
argument :junk-allowed, which tells it to relax a bit.

bc. (parse-integer (prompt-read "Rating") :junk-allowed t)

But there’s still one problem: if it can’t find an integer amidst all
the junk, PARSE-INTEGER will return NIL rather than a number. In
keeping with the quick-and-dirty approach, you may just want to call
that 0 and continue. Lisp’s OR macro is just the thing you need
here. It’s similar to the “short-circuiting” || in Perl, Python, Java,
and C; it takes a series of expressions, evalu- ates them one at a
time, and returns the first non-nil value (or NIL if they’re all
NIL). So you can use the following:

bc. (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)

h3. Booleans

Fixing the code to prompt for Ripped is quite a bit simpler. You can just use the Common
Lisp function Y-OR-N-P.

bc. (y-or-n-p "Ripped [y/n]: ")

Putting it all together:

bc. 
(defun prompt-for-cd ()
 (make-cd
 (prompt-read "Title")
 (prompt-read "Artist")
 (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
 (y-or-n-p "Ripped [y/n]: ")))

h2. File I/O

h3. Write to file

The @WITH-OPEN-FILE@ macro opens a file, binds the stream to a variable,
executes a set of expressions, and then closes the file. It also makes
sure the file is closed even if something goes wrong while evaluating
the body. The list directly after @WITH-OPEN-FILE@ isn’t a function call
but rather part of the syntax defined by @WITH-OPEN-FILE@. 

@out@ = It contains the name of the variable that will hold the file stream to
which you’ll write within the body of @WITH-OPEN-FILE@,

@filename@ = a value that must be a file name,

and then some options that control how the file is
opened. Here you specify that you’re opening the file for writing with
@:direction :output@ and that you want to overwrite an existing file of
the same name if it exists with @:if-exists :supersede@.

Once you have the file open, all you have to do is print the contents
of the database with @(print *db* out)@. Unlike @FORMAT, PRINT@ prints
Lisp objects in a form that can be read back in by the Lisp
reader. The macro @WITH-STANDARD-IO-SYNTAX@ ensures that certain
variables that affect the behavior of @PRINT@ are set to their standard
values. You’ll use the same macro when you read the data back in to
make sure the Lisp reader and printer are operating compatibly.

bc. 
(defun save-db (filename)
 (with-open-file (out filename
  :direction :output
  :if-exists :supersede)
 (with-standard-io-syntax
 (print *db* out))))

h3. Read from file

bc. 
(defun load-db (filename)
 (with-open-file (in filename)
 (with-standard-io-syntax
 (setf *db* (read in)))))

This time you don’t need to specify :direction in the options to
WITH-OPEN-FILE, since you want the default of :input. And instead of
printing, you use the function READ to read from the stream @in@.

The @SETF@ macro is Common Lisp’s main assignment operator. It sets its first argument to
the result of evaluating its second argument. So in @load-db@ the @*db*@ variable will contain the
object read from the file, namely, the list of lists written by save-db. You do need to be careful
about one thing—load-db clobbers whatever was in @*db*@ before the call. So if you’ve added
records with add-record or add-cds that haven’t been saved with save-db, you’ll lose them.

h2. List Processing 

h3. REMOVE-IF-NOT

The function @REMOVE-IF-NOT@ takes a predicate and a list and returns a list containing only
the elements of the original list that match the predicate. In other words, it has removed all the
elements that don’t match the predicate. However, @REMOVE-IF-NOT@ doesn’t really remove
anything—it creates a new list, leaving the original list untouched. 

h3. DOLIST

The @DOLIST@ macro works by looping over all the elements of @*db*@ with
the @DOLIST@ macro, binding each element to the variable cd in turn. For
each value of cd, you use the @FORMAT@ function to print it.

bc. 
(defun dump-db ()
 (dolist (cd *db*)
  (format t "~{~a:~10t~a~%~}~%" cd)))

h2. Other Commands

* Define a new function

bc. (defun <function_name> <paren_list> <function>)

* Define a variable (with DEFVAR macro)

bc. (defvar *data* nil)




* Loading a file full of lisp

bc. (load "myFunctions.lisp")

* Load defun into lisp (do anywhere in or immediately after defun)

bc. C-c C-c

* Switch to the REPL

bc. C-c C-z

* Quit

bc. , quit

* Exit the debugger

bc. q

* Compile a file, creates "hello.fasl" (FASt Load)

bc. (compile-file "hello.lisp")

* Compile and load the file in the current buffer

bc. C-c C-k

* Make a list function, constructs a list from its arguments

bc. (list 1 2 3)
(1 2 3)

* A plist or property list (like a hash map) contains key=>value pairs. A plist is a list where every other element, starting with the first, is a symbol that describes what the next element in the list is. A keyword is any name that starts with a colon (:), for instance, :foo. 

bc. (list :a 1 :b 2 :c 3)

* The function GETF, which takes a plist and a symbol and returns the value in the plist following the symbol

bc. (GETF (list :a 1 :b 2 :c 3) :a)
(1)
