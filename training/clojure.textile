"home":/index.html > Clojure

p(toc). Table of Contents

{toc}

h1. Installation

"Ref Website":http://riddell.us/ClojureSwankLeiningenWithEmacsOnLinux.html

This tutorial is provided as a very specific approach to installing a
clojure environment on linux. Although an attempt is made to keep it
up to date, the various technologies used are moving very fast. The
following list contains links to the offical documentation of the most
relevant packages.

* Clojure Wiki - Getting Started: http://www.assembla.com/wiki/show/clojure/Getting_Started
* Leiningen: http://github.com/technomancy/leiningen

h3. Command line support

* Install Java

bc. ~$ sudo apt-get install sun-java6-jdk

* Install Ant

bc. ~$ sudo apt-get install ant

* Install Maven

bc. ~$ sudo apt-get install maven2

* Install Git

bc. ~$ sudo apt-get install git-core

* Install Clojure

bc. 
~$ mkdir ~/opt
~$ cd ~/opt
~$ git clone git://github.com/clojure/clojure.git
~$ cd clojure
~$ ant
~$ mkdir ~/.clojure
~$ cp clojure.jar ~/.clojure

* Test Clojure

Gentlemen, start your REPLs.

bc. 
~$ cd ~/.clojure 
~$ java -cp clojure.jar clojure.main
user=> (+ 1 41) 
42 

Ctrl-d will exit the REPL.

* Install clojure-contrib
 
bc. 
~$ cd ~/opt 
~$ git clone git://github.com/clojure/clojure-contrib.git 
~$ cd clojure-contrib 
~$ mvn install 

* Configure Bash Start-up Script

clojure-contrib contains a bash script called clj-env-dir for starting
clojure with various options. Edit your ~/.bashrc file to configure
this script.

bc. 
export CLOJURE_EXT=~/.clojure
export PATH=$PATH:~/opt/clojure-contrib/launchers/bash
alias clj=clj-env-dir

The last line added to the file above sets an alias to the clj-env-dir
script. This example uses clj but it could be set to anything.

See the file at @~/opt/clojure-contrib/launchers/bash/clj-env-dir@ for
more options.

h3. Add JLine support

* Download JLine from @http://jline.sourceforge.net/@ and unzip and copy
jar to the @~/.clojure@ directory.

* Add jline.ConsoleRunner to the last line in
@~/opt/clojure-contrib/launchers/bash/clj-env-dir@ to add JLine
functionality.

bc. exec $JAVA $OPTS jline.ConsoleRunner $MAIN "$@"

* Test the Script

To test the new script and verify access to the clojure-contrib
library, open a new terminal window and try this:

bc. 
~$ clj
user=> (System/getProperty "java.class.path")

If any other jars are needed either copy or link them to the
@~/.clojure@ directory.

h3. Emacs support

* Install Emacs

bc. ~$ sudo apt-get install emacs-snapshot-gtk

* Install Slime

bc. 
~$ cd ~/opt
~$ git clone git://github.com/nablaone/slime.git

* Install clojure-mode

~$ cd ~/opt 
~$ git clone git://github.com/technomancy/clojure-mode.git 

h3. Install leiningen

bc. 
~$ cd ~/opt
~$ git clone https://github.com/technomancy/leiningen.git
~$ cd leiningen/bin
!$ chmod +x lein; ./lein self-install  # or maybe just ./lein is enough

* Add the following to .bashrc.

bc. export PATH=$PATH:~/opt/leiningen

* Execute the leiningen script.

bc. 
~$ chmod +x lein
~$ ./lein self-install

h3. Configure Emacs

* Add these specifics to the .emacs file.

bc. 
;; clojure-mode
(add-to-list 'load-path "~/opt/clojure-mode")
(require 'clojure-mode)
;; slime
(eval-after-load "slime" 
  '(progn (slime-setup '(slime-repl))))
(add-to-list 'load-path "~/opt/slime")
(require 'slime)
(slime-setup)

h3. Test Configuration

h4. Create a test project.

bc. 
~$ mkdir ~/tmp
~$ cd tmp
~$ lein new test-project
~$ cd test-project
~$ emacs project.clj

* Add the following:

bc. 
(defproject test-project "0.1.0"
  :description "Test Project"
  :dependencies [[org.clojure/clojure "1.2.0-master-SNAPSHOT"]
                 [org.clojure/clojure-contrib "1.2.0-SNAPSHOT"]]
  :dev-dependencies [[swank-clojure "1.2.1"]])

* Save and exit the file.

bc. 
~$ lein deps
~$ lein swank

* Open a new terminal and open the generated file in emacs:

bc. 
~$ emacs ~/tmp/test-project/src/test_project/core.clj

* Connect to the running swank server:

bc. M-x slime-connect

Add some code to the file:

bc. (System/getProperty "java.class.path")

And then at the end of the line, evaluate:

bc. C-x C-e

The output will show the configured jar files and their associated
paths on the Java classpath.

Lastly, compile the file:

bc. C-c C-k

|| Keyboard Shortcut || Effect                                 ||
| C-c C-k            | Compile the current buffer               |
| C-x C-e            | Evaluate the expression under the cursor |

h1. Using Clojure

h2. Data

To convert a list from the standard form to simply data, precede it with a single quote:

bc. '(a b c)

h2. Help

To get help use the @(doc <function-name>)@ or @(find-doc "<a part of the function name>")@

h2. Bindings

The def special form creates a global binding and optionally gives it a "root value" that is visible in all threads unless a thread-local value is assigned. def can also be used to change the root value of an existing binding. However, doing this is frowned upon because it sacrifices the benefits of working with immutable data.

bc. (def v 1) ; v is a global binding

Function parameters are bindings that are local to the function.

h3. let

let creates a binding that is local that form

bc. 
(def v 1) ; v is a global binding
(defn f1 []
 (println "v = " v)  ;; will print: v = 1
 (let [v 2]          ;; creates a local binding that shadows the global one
  (println "v = " v) ;; will print: v = 2
  (f2)))             
(defn f2 []
 (println "v = " v)  ;; will print: v = 1
(f1)                 ;; kick off the program

The call to @f2@ above will produce "v = 1" because when you call the function, you leave the form, and let bindings are only local to that form.

h3. map

map applys a function to every item in a list, example: an anonymous function that adds three to its parameter.  map returns a lazy-sequence.

bc. (map #(+ % 3) [2 4 7]) ; -> (5 7 10)

h3. apply

apply takes a function and a collection.  The result is when all the items in a given collection are used as arguments to the supplied function.

bc. (apply + [2 4 7]); -> 13

h3. assoc

The assoc function operates on vectors and maps. When applied to a
vector, it creates a new vector where the item specified by an index
is replaced. If the index is equal to the number of items in the
vector, a new item is added to the end. If it is greater than the
number of items in the vector, an IndexOutOfBoundsException is
thrown. For example:

bc. (assoc stooges 2 "Shemp") ; -> ["Moe" "Larry" "Shemp"]

h3. sets

Sets can be used as functions of their items. When used in this way, they return the item or nil. 

bc. 
(def stooges (sorted-set "Moe" "Larry" "Curly"))
(stooges "Moe") ; -> "Moe"

h3. conj

Add to the back of a sequence

h3. cons

Add to the start of a sequence

h2. lists

list literal: @(...)@

bc. 
(def stooges (list "Moe" "Larry" "Curly"))
(def stooges (quote ("Moe" "Larry" "Curly")))
(def stooges '("Moe" "Larry" "Curly"))

h2. vectors

vector literal: @[...]@

bc. 
(def stooges (vector "Moe" "Larry" "Curly"))
(def stooges ["Moe" "Larry" "Curly"])

h2. sets

set literal: @#{...}@

bc. 
(def stooges (hash-set "Moe" "Larry" "Curly")) ; not sorted
(def stooges #{"Moe" "Larry" "Curly"}) ; same as previous
(def stooges (sorted-set "Moe" "Larry" "Curly"))


h2. maps 

map literal @{...}@

bc. {:red :cherry, :green :apple, :purple :grape}

Maps store associations between keys and their corresponding values
where both can be any kind of object. Often keywords are used for map
keys. Entries can be stored in such a way that the pairs can be
quickly retrieved in sorted order based on their keys.

Here are some ways to create maps that store associations from
popsicle colors to their flavors where the keys and values are both
keywords. The commas aid readability. They are optional and are
treated as whitespace.

bc. 
(def popsicle-map
  (hash-map :red :cherry, :green :apple, :purple :grape))
(def popsicle-map
  {:red :cherry, :green :apple, :purple :grape}) ; same as previous
(def popsicle-map
  (sorted-map :red :cherry, :green :apple, :purple :grape))

Maps can be used as functions of their keys. Also, in some cases keys
can be used as functions of maps. For example, keyword keys can, but
string and integer keys cannot. The following are all valid ways to
get the flavor of green popsicles, which is :apple:

(get popsicle-map :green)
(popsicle-map :green)
(:green popsicle-map)

When used in the context of a sequence, maps are treated like a
sequence of clojure.lang.MapEntry objects. This can be combined with
the use of doseq and destructuring, both of which are described in
more detail later, to easily iterate through all the keys and
values. The following example iterates through all the key/value pairs
in popsicle-map and binds the key to color and the value to
flavor. The name function returns the string name of a keyword.

bc. 
(doseq [[color flavor] popsicle-map]
  (println (str "The flavor of " (name color)
    " popsicles is " (name flavor) ".")))

The output produced by the code above follows:

bc. 
The flavor of green popsicles is apple.
The flavor of purple popsicles is grape.
The flavor of red popsicles is cherry.

bc. 
(def person {
  :name "Mark Volkmann"
  :address {
    :street "644 Glen Summit"
    :city "St. Charles"
    :state "Missouri"
    :zip 63304}
  :employer {
    :name "Object Computing, Inc."
    :address {
      :street "12140 Woodcrest Executive Drive, Suite 250"
      :city "Creve Coeur"
      :state "Missouri"
      :zip 63141}}})

The get-in function takes a map and a key sequence. It returns the
value of the nested map key at the end of the sequence. The -> macro
and the reduce function can also be used for this purpose. All of
these are demonstrated below to retrieve the employer city which is
"Creve Coeur".

bc. 
(get-in person [:employer :address :city])
(-> person :employer :address :city) ; explained below
(reduce get person [:employer :address :city]) ; explained below

The -> macro, referred to as the "thread" macro, calls a series of
functions, passing the result of each as an argument to the next. For
example the following lines have the same result:

bc. 
(f1 (f2 (f3 x)))
(-> x f3 f2 f1)

There is also a -?> macro in the clojure.contrib.core namespace that
stops and returns nil if any function in the chain returns nil. This
avoids getting a NullPointerException.

h2. StructMaps

StructMaps are similar to regular maps, but are optimized to take
advantage of common keys in multiple instances so they don't have to
be repeated. Their use is similar to that of Java Beans. Proper equals
and hashCode methods are generated for them. Accessor functions that
are faster than ordinary map key lookups can easily be created.

The create-struct function and defstruct macro, which uses
create-struct, both define StructMaps. The keys are normally specified
with keywords. For example:

bc. 
(def car-struct (create-struct :make :model :year :color)) ; long way
(defstruct car-struct :make :model :year :color) ; short way

The struct function creates an instance of a given StructMap. Values
must be specified in the same order as their corresponding keys were
specified when the StructMap was defined. Values for keys at the end
can be omitted and their values will be nil. For example:

bc. (def car (struct car-struct "Toyota" "Prius" 2009))

The accessor function creates a function for accessing the value of a
given key in instances that avoids performing a hash map lookup. For
example:

bc. 
; Note the use of def instead of defn because accessor returns
; a function that is then bound to "make".
(def make (accessor car-struct :make))
(make car) ; -> "Toyota"
(car :make) ; same but slower
(:make car) ; same but slower

New keys not specified when the StructMap was defined can be added to
instances. However, keys specified when the StructMap was defined
cannot be removed from instances.

h2. Defining Functions

The defn macro defines a function. Its arguments are the function
name, an optional documentation string (displayed by the doc macro),
the parameter list (specified with a vector that can be empty) and the
function body. The result of the last expression in the body is
returned. Every function returns a value, but it may be nil. For
example:

bc. 
(defn function-name 
 "documenations" 
 [parameter list] 
 ... rest of function )

example:

bc. 
(defn parting
  "returns a String parting"
  [name]
  (str "Goodbye, " name)) ; concatenation
(println (parting "Mark")) ; -> Goodbye, Mark



h3. annonymous functions

@#(...)@, putting a hash in front of the parens is how to make an anonymous function
