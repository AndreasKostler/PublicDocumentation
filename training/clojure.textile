"home":/index.html > Clojure

p(toc). Table of Contents

{toc}

h1. Installation

"Ref Website":http://riddell.us/ClojureSwankLeiningenWithEmacsOnLinux.html

This tutorial is provided as a very specific approach to installing a
clojure environment on linux. Although an attempt is made to keep it
up to date, the various technologies used are moving very fast. The
following list contains links to the offical documentation of the most
relevant packages.

* Clojure Wiki - Getting Started: http://www.assembla.com/wiki/show/clojure/Getting_Started
* Leiningen: http://github.com/technomancy/leiningen

h3. Command line support

* Install Java

bc. ~$ sudo apt-get install sun-java6-jdk

* Install Ant

bc. ~$ sudo apt-get install ant

* Install Maven

bc. ~$ sudo apt-get install maven2

* Install Git

bc. ~$ sudo apt-get install git-core

h3(#install_clojure). Install Clojure

bc. 
~$ mkdir ~/bin
~$ cd ~/bin
~$ git clone git://github.com/clojure/clojure.git
~$ cd clojure
~$ ant
~$ mkdir ~/.clojure
~$ cp clojure.jar ~/.clojure

* Test Clojure

Gentlemen, start your REPLs.

bc. 
~$ cd ~/.clojure 
~$ java -cp clojure.jar clojure.main
user=> (+ 1 41) 
42 

Ctrl-d will exit the REPL.

h3(#install_clojContrib). Install clojure-contrib 

bc. 
~$ cd ~/bin 
~$ git clone git://github.com/clojure/clojure-contrib.git 
~$ cd clojure-contrib 
~$ mvn install 

* Configure Bash Start-up Script

clojure-contrib contains a bash script called clj-env-dir for starting
clojure with various options. Edit your ~/.bashrc file to configure
this script.

bc. 
export CLOJURE_EXT=~/.clojure
export PATH=$PATH:~/bin/clojure-contrib/launchers/bash
alias clj=clj-env-dir

The last line added to the file above sets an alias to the clj-env-dir
script. This example uses clj but it could be set to anything.

See the file at @~/bin/clojure-contrib/launchers/bash/clj-env-dir@ for
more options.

h3. Add JLine support

* Download JLine from @http://jline.sourceforge.net/@ and unzip and copy
jar to the @~/.clojure@ directory.

* Add jline.ConsoleRunner to the last line in
@~/bin/clojure-contrib/launchers/bash/clj-env-dir@ to add JLine
functionality.

bc. exec $JAVA $OPTS jline.ConsoleRunner $MAIN "$@"

* Test the Script

To test the new script and verify access to the clojure-contrib
library, open a new terminal window and try this:

bc. 
~$ clj
user=> (System/getProperty "java.class.path")

If any other jars are needed either copy or link them to the
@~/.clojure@ directory.

h3. Emacs support

* Install Emacs

bc. ~$ sudo apt-get install emacs-snapshot-gtk

* Install Slime

bc. 
~$ cd ~/bin
~$ git clone git://github.com/nablaone/slime.git

* Install clojure-mode

bc. 
~$ cd ~/bin 
~$ git clone git://github.com/technomancy/clojure-mode.git

h3(#install_lein). Install leiningen

bc. 
$ cd ~/bin
$ git clone https://github.com/technomancy/leiningen.git
$ cd leiningen/bin
$ ./lein self-install

* Add the following to .bashrc.

bc. export PATH=$PATH:~/bin/leiningen

h3. Configure Emacs

* Add these specifics to the .emacs file.

bc. 
;; clojure-mode
(add-to-list 'load-path "~/bin/clojure-mode")
(require 'clojure-mode)
;; slime
(eval-after-load "slime" 
  '(progn (slime-setup '(slime-repl))))
(add-to-list 'load-path "~/bin/slime")
(require 'slime)
(slime-setup)

h3. Test Configuration

h4. Create a test project.

bc. 
~$ mkdir ~/tmp
~$ cd tmp
~$ lein new test-project
~$ cd test-project
~$ emacs project.clj

* Add the following:

bc. 
(defproject test-project "0.1.0"
  :description "Test Project"
  :dependencies [[org.clojure/clojure "1.2.0-master-SNAPSHOT"]
                 [org.clojure/clojure-contrib "1.2.0-SNAPSHOT"]]
  :dev-dependencies [[swank-clojure "1.2.1"]])

* Save and exit the file.

bc. 
~$ lein deps
~$ lein swank

* Open a new terminal and open the generated file in emacs:

bc. 
~$ emacs ~/tmp/test-project/src/test_project/core.clj

* Connect to the running swank server:

bc. M-x slime-connect

Add some code to the file:

bc. (System/getProperty "java.class.path")

And then at the end of the line, evaluate:

bc. C-x C-e

The output will show the configured jar files and their associated
paths on the Java classpath.

Lastly, compile the file:

bc. C-c C-k

|| Keyboard Shortcut || Effect                                 ||
| C-c C-k            | Compile the current buffer               |
| C-x C-e            | Evaluate the expression under the cursor |

h2. Installation Method 2

source: "http://www.assembla.com/wiki/show/clojure/Getting_Started_with_Emacs":http://www.assembla.com/wiki/show/clojure/Getting_Started_with_Emacs

* Use the .emacs starter kit

bc. 
~$ cd ~
~$ git clone https://github.com/technomancy/emacs-starter-kit.git
~$ mv ~/.emacs.d ~/.emacs.d.orig
~$ mv ~/emacs-starter-kit ~/.emacs.d

* Start Emacs

do: @Alt-x package-list-packages@ and select clojure-mode (press i),
and then install the selected package (press x).

Go back to the packages list with M-x package-list-packages and choose
slime-repl.

* "Install clojure":install_clojure
* "Install clojure-contrib":install_clojContrib
* "Install Lein":#install_lein





* update ~/.emacs with:

bc. 
(require 'package)





h1. Using Clojure 

"Source of the following info":http://java.ociweb.com/mark/clojure/article.html

h2. Data

To convert a list from the standard form to simply data, precede it with a single quote:

bc. '(a b c)

h2. Help

To get help use the @(doc <function-name>)@ or @(find-doc "<a part of the function name>")@

"API":http://clojure.org/api

h2. load code

If you have a block of code that is too large to conveniently type at the
REPL, save the code into a file, and then load that file from the REPL.
You can use an absolute path or a path relative to where you launched
the REPL:

bc. (load-file "temp.clj")

h2. refs

@ref@ creates reference.

bc. (ref initial-state)

bc. (ref #{}) 

Creates a reference to an empty set.

We can bind this to a symbol by using def:

bc. (def symbol initial-value?)

bc. (def visitors (ref #{}))

Use ref to create a reference, and use def to bind this reference to the
name visitors.

In order to update a reference, you must use a function such as @alter@.

bc. (alter ref update-fn & args)

h2. &

The ampersand means what follows is a collection of arguments.  Or an argument that is a collection.

bc. (function & expressions)

h2. state

h3. Alter

To create a transaction do:

bc. (dosync & exprs)

Use dosync to add a visitor within a transaction

bc. (dosync (alter visitors conj "Stu"))

h3. Examine

At any time, you can peek inside the ref with deref or with the shorter
@:

bc. (deref visitors)

or

bc. @visitors

h2. Bindings

The def special form creates a global binding and optionally gives it
a "root value" that is visible in all threads unless a thread-local
value is assigned. def can also be used to change the root value of an
existing binding. However, doing this is frowned upon because it
sacrifices the benefits of working with immutable data. A def can
define functions or data.

bc. (def v 1) ; v is a global binding

Function parameters are bindings that are local to the function.

h3. let

let creates a binding that is local that form

bc. 
(def v 1) ; v is a global binding
(defn f2 []
 (println "v = " v)  ;; will print: v = 1
(defn f1 []
 (println "v = " v)  ;; will print: v = 1
 (let [v 2]          ;; creates a local binding that shadows the global one
  (println "v = " v) ;; will print: v = 2
  (f2)))             
(f1)                 ;; kick off the program

The call to @f2@ above will produce "v = 1" because when you call the function, you leave the form, and let bindings are only local to that form.

h3. sets are functions of their members

bc. (@visitors name)

@visitors returns the current value of the visitors reference.
Sets are functions of their members, so (@visitors username) checks to
see whether @name@ is a member of the current value of visitors. The let
then binds the result of this check to the name past-visitor.

h3. map

map applys a function to every item in a list, example: an anonymous function that adds three to its parameter.  map returns a lazy-sequence.

bc. (map #(+ % 3) [2 4 7]) ; -> (5 7 10)

h3. apply

apply takes a function and a collection.  The result is when all the items in a given collection are used as arguments to the supplied function.

bc. (apply + [2 4 7]); -> 13

h3. assoc

The assoc function operates on vectors and maps. When applied to a
vector, it creates a new vector where the item specified by an index
is replaced. If the index is equal to the number of items in the
vector, a new item is added to the end. If it is greater than the
number of items in the vector, an IndexOutOfBoundsException is
thrown. For example:

bc. (assoc stooges 2 "Shemp") ; -> ["Moe" "Larry" "Shemp"]

h3. sets

Sets can be used as functions of their items. When used in this way, they return the item or nil. 

bc. 
(def stooges (sorted-set "Moe" "Larry" "Curly"))
(stooges "Moe") ; -> "Moe"

h3. conj

Add to the back of a sequence

h3. cons

Add to the start of a sequence

h2. lists

list literal: @(...)@

bc. 
(def stooges (list "Moe" "Larry" "Curly"))
(def stooges (quote ("Moe" "Larry" "Curly")))
(def stooges '("Moe" "Larry" "Curly"))

h2. vectors

vector literal: @[...]@

bc. 
(def stooges (vector "Moe" "Larry" "Curly"))
(def stooges ["Moe" "Larry" "Curly"])

h2. sets

set literal: @#{...}@

bc. 
(def stooges (hash-set "Moe" "Larry" "Curly")) ; not sorted
(def stooges #{"Moe" "Larry" "Curly"}) ; same as previous
(def stooges (sorted-set "Moe" "Larry" "Curly"))


h2. maps 

map literal @{...}@

bc. {:red :cherry, :green :apple, :purple :grape}

Maps store associations between keys and their corresponding values
where both can be any kind of object. Often keywords are used for map
keys. Entries can be stored in such a way that the pairs can be
quickly retrieved in sorted order based on their keys.

Here are some ways to create maps that store associations from
popsicle colors to their flavors where the keys and values are both
keywords. The commas aid readability. They are optional and are
treated as whitespace.

bc. 
(def popsicle-map
  (hash-map :red :cherry, :green :apple, :purple :grape))
(def popsicle-map
  {:red :cherry, :green :apple, :purple :grape}) ; same as previous
(def popsicle-map
  (sorted-map :red :cherry, :green :apple, :purple :grape))

Maps can be used as functions of their keys. Also, in some cases keys
can be used as functions of maps. For example, keyword keys can, but
string and integer keys cannot. The following are all valid ways to
get the flavor of green popsicles, which is :apple:

(get popsicle-map :green)
(popsicle-map :green)
(:green popsicle-map)

When used in the context of a sequence, maps are treated like a
sequence of clojure.lang.MapEntry objects. This can be combined with
the use of doseq and destructuring, both of which are described in
more detail later, to easily iterate through all the keys and
values. The following example iterates through all the key/value pairs
in popsicle-map and binds the key to color and the value to
flavor. The name function returns the string name of a keyword.

bc. 
(doseq [[color flavor] popsicle-map]
  (println (str "The flavor of " (name color)
    " popsicles is " (name flavor) ".")))

The output produced by the code above follows:

bc. 
The flavor of green popsicles is apple.
The flavor of purple popsicles is grape.
The flavor of red popsicles is cherry.

bc. 
(def person {
  :name "Mark Volkmann"
  :address {
    :street "644 Glen Summit"
    :city "St. Charles"
    :state "Missouri"
    :zip 63304}
  :employer {
    :name "Object Computing, Inc."
    :address {
      :street "12140 Woodcrest Executive Drive, Suite 250"
      :city "Creve Coeur"
      :state "Missouri"
      :zip 63141}}})

The get-in function takes a map and a key sequence. It returns the
value of the nested map key at the end of the sequence. The -> macro
and the reduce function can also be used for this purpose. All of
these are demonstrated below to retrieve the employer city which is
"Creve Coeur".

bc. 
(get-in person [:employer :address :city])
(-> person :employer :address :city) ; explained below
(reduce get person [:employer :address :city]) ; explained below

The -> macro, referred to as the "thread" macro, calls a series of
functions, passing the result of each as an argument to the next. For
example the following lines have the same result:

bc. 
(f1 (f2 (f3 x)))
(-> x f3 f2 f1)

There is also a -?> macro in the clojure.contrib.core namespace that
stops and returns nil if any function in the chain returns nil. This
avoids getting a NullPointerException.

h2. StructMaps

StructMaps are similar to regular maps, but are optimized to take
advantage of common keys in multiple instances so they don't have to
be repeated. Their use is similar to that of Java Beans. Proper equals
and hashCode methods are generated for them. Accessor functions that
are faster than ordinary map key lookups can easily be created.

The create-struct function and defstruct macro, which uses
create-struct, both define StructMaps. The keys are normally specified
with keywords. For example:

bc. 
(def car-struct (create-struct :make :model :year :color)) ; long way
(defstruct car-struct :make :model :year :color) ; short way

The struct function creates an instance of a given StructMap. Values
must be specified in the same order as their corresponding keys were
specified when the StructMap was defined. Values for keys at the end
can be omitted and their values will be nil. For example:

bc. (def car (struct car-struct "Toyota" "Prius" 2009))

The accessor function creates a function for accessing the value of a
given key in instances that avoids performing a hash map lookup. For
example:

bc. 
; Note the use of def instead of defn because accessor returns
; a function that is then bound to "make".
(def make (accessor car-struct :make))
(make car) ; -> "Toyota"
(car :make) ; same but slower
(:make car) ; same but slower

New keys not specified when the StructMap was defined can be added to
instances. However, keys specified when the StructMap was defined
cannot be removed from instances.

h2. Defining Functions

The defn macro defines a function. Its arguments are the function
name, an optional documentation string (displayed by the doc macro),
the parameter list (specified with a vector that can be empty) and the
function body. The result of the last expression in the body is
returned. Every function returns a value, but it may be nil. For
example:

bc. 
(defn function-name 
 "documenations" 
 [parameter list] 
 ( ... rest of function ))

example:

bc. 
(defn parting
  "returns a String parting"
  [name]
  (str "Goodbye, " name)) ; concatenation
(println (parting "Mark")) ; -> Goodbye, Mark

h3. scope 

Functions defined with the defn- macro are private. This means they
are only visible in the namespace in which they are defined. Other
macros that produce private definitions, such as defmacro- and
defstruct-, are in clojure.contrib.def.

h3. var args

Functions can take a variable number of parameters. Optional
parameters must appear at the end. They are gathered into a list by
adding an ampersand and a name for the list at the end of the
parameter list.

bc. 
(defn power [base & exponents]
  ; Using java.lang.Math static method pow.
  (reduce #(Math/pow %1 %2) base exponents))
(power 2 3 4) ; 2 to the 3rd = 8; 8 to the 4th = 4096

h3. function overloading, arity

Function definitions can contain more than one parameter list and
corresponding body. Each parameter list must contain a different
number of parameters. This supports overloading functions based on
arity. Often it is useful for a body to call the same function with a
different number of arguments in order to provide default values for
some of them. For example:

bc. 
(defn parting
  "returns a String parting in a given language"
  ([] (parting "World"))
  ([name] (parting name "en"))
  ([name language]
    ; condp is similar to a case statement in other languages.
    ; It is described in more detail later.
    ; It is used here to take different actions based on whether the
    ; parameter "language" is set to "en", "es" or something else.
    (condp = language
      "en" (str "Goodbye, " name)
      "es" (str "Adios, " name)
      (throw (IllegalArgumentException.
        (str "unsupported language " language))))))
(println (parting)) ; -> Goodbye, World
(println (parting "Mark")) ; -> Goodbye, Mark
(println (parting "Mark" "es")) ; -> Adios, Mark
(println (parting "Mark", "xy"))
; -> java.lang.IllegalArgumentException: unsupported language xy

h3. annonymous functions

@#(...)@, putting a hash in front of the parens is how to make an anonymous function

Anonymous functions have no name. These are often passed as arguments
to a named function. They are handy for short function definitions
that are only used in one place. There are two ways to define them,
shown below:

bc. 
(def years [1940 1944 1961 1985 1987])
(filter (fn [year] (even? year)) years) ; long way w/ named arguments -> (1940 1944)
(filter #(even? %) years) ; short way where % refers to the argument

When an anonymous function is defined using the fn special form, the
body can contain any number of expressions.

When an anonymous function is defined in the short way using #(...),
it can only contain a single expression. To use more than one
expression, wrap them in the do special form. If there is only one
parameter, it can be referred to with %. If there are multiple
parameters, they are referred to with %1, %2 and so on. For example:

bc. 
(defn pair-test [test-fn n1 n2]
  (if (test-fn n1 n2) "pass" "fail"))
; Use a test-fn that determines whether
; the sum of its two arguments is an even number.
(println (pair-test #(even? (+ %1 %2)) 3 5)) ; -> pass

Java methods can be overloaded based on parameter types. Clojure
functions can only be overloaded on arity. Clojure multimethods
however, can be overloaded based on anything.

The defmulti and defmethod macros are used together to define a
multimethod. 

The arguments to defmulti are:

* the method name and 
* the dispatch function which returns a value that will be used to select a
method. 

The arguments to defmethod are:

* the method name, 
* the dispatch value that triggers use of the method, 
* the parameter list and 
* the body. 

The special dispatch value :default is used to designate a
method to be used when none of the others match. Each defmethod for
the same multimethod name must take the same number of arguments. The
arguments passed to a multimethod are passed to the dispatch function.

Here's an example of a multimethod that overloads based on type.

bc. 
(defmulti what-am-i class) ; class is the dispatch function
(defmethod what-am-i Number [arg] (println arg "is a Number"))
(defmethod what-am-i String [arg] (println arg "is a String"))
(defmethod what-am-i :default [arg] (println arg "is something else"))
(what-am-i 19) ; -> 19 is a Number
(what-am-i "Hello") ; -> Hello is a String
(what-am-i true) ; -> true is something else

class returns the class of its argument.  So basically when we call
what-am-i an argument x, x is passed to the function 'class' and the
result of that function is compared to the 3rd value in the defmethod
calls.  When a match is found, x is then passed along into the
function defined at the end of defmethod.

Since the dispatch function can be any function, including one you
write, the possibilities are endless. For example, a custom dispatch
function could examine its arguments and return a keyword to indicate
a size such as :small, :medium or :large. One method for each size
keyword can provide logic that is specific to a given size.

Underscores can be used as placeholders for function parameters that
won't be used and therefore don't need a name. This is often useful in
callback functions which are passed to another function so they can be
invoked later. A particular callback function may not use all the
arguments that are passed to it. For example:

bc. 
(defn callback1 [n1 n2 n3] (+ n1 n2 n3)) ; uses all three arguments
(defn callback2 [n1 _ n3] (+ n1 n3)) ; only uses 1st & 3rd arguments
(defn caller [callback value]
  (callback (+ value 1) (+ value 2) (+ value 3)))
(caller callback1 10) ; 11 + 12 + 13 -> 36
(caller callback2 10) ; 11 + 13 -> 24

h2. Java Interoperability

Clojure programs can use all Java classes and interfaces. As in Java,
classes in the java.lang package can be used without importing
them. Java classes in other packages can be used by either specifying
their package when referencing them or using the import function. For
example:

bc. 
(import
  '(java.util Calendar GregorianCalendar)
  '(javax.swing JFrame JLabel))

bc. 
(.toUpperCase "hello")

The dot before toUpperCase tells Clojure to treat it as the name of a Java
method instead of a Clojure function.

h2. Parameter naming conventions

||Parameter|| Usage||
|a    |A Java array|
|agt  |An agent|
|coll |A collection|
|expr |An expression|
|f    |A function|
|idx  |Index|
|r    |A ref|
|v    |A vector|
|val  |A value|

h2. form grammar

bc. 
(example-fn required-arg)
(example-fn optional-arg?)
(example-fn zero-or-more-arg*)
(example-fn one-or-more-arg+)
(example-fn & collection-of-variable-args)



h1. Cookbook with Explanations

h2. file writing

bc. 
(use '[clojure.contrib.duck-streams :only (spit)])
(spit "hello.out" "hello, world")

This program writes the string "hello, world" out to the file @hello.out@.

The first line is like the import line in java.

The simple form of @use@ 

bc. (use 'clojure.contrib.duck-streams)

causes the current namespace to refer to all public vars in
clojure.contrib.duck-streams. This can be confusing, because it does
not make explicit which names are being referred to.  Be nice to
future readers of your code, and pass the :only option to use, listing
only the vars you need:

The definition of spit is: 

bc. 
; from clojure-contrib
(defn spit [f content]
 (with-open [#^PrintWriter w (writer f)]
  (.print w content)
 )
)

The @with-open@ function's general form is: 

bc. (with-open [name init-form] & body)

Internally, with-open creates a try block, sets @name@ to the result of
@init-form@, and then runs the forms in @body@. Most important, with-open
always closes the object bound to name in a finally block.





h1. Projects

h2. Scrape a web page

So for this project, I want to parse some JSON XML that I get by
calling a URL.

The java code uses the HttpClient library and looks like:

bc. 
String url = "http://search.oracle.com?&search.timezone=-480&group=All&search_p_main_operator=all";
HttpClient client = new HttpClient();
client.getHostConfiguration().setProxy("www-proxy.us.oracle.com", 80);
GetMethod method = new GetMethod(url);
method.getResponseBodyAsString();

So the first step is to get the dependent library in place.
