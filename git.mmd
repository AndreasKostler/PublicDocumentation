## Normal Development Workflow

The following example demonstrates how a normal coding workflow should
be executed.  A simple file will be used to demonstrate how these
things work.  The file is called `testBranch.mmd` and only has the
following line in it to start with.  It is on the master branch.

    Starting file in _master_ branch.

Commit this file on master like so:

    $ git commit -am'Starting commit on _master_'
    [master 62e2f60] Starting commit on _master_
     1 files changed, 1 insertions(+), 2 deletions(-)

## Branch

The first step is to make a branch, we'll call it `branch1`.

    $ git checkout -b branch1
    Switched to a new branch 'branch1'

Now lets add an additional line:

    Starting file in _master_ branch. 
    First commit on branch1.

and commit our change on `branch1`.

    $ git commit -am'First commit on branch1'
    [branch1 36a404f] First commit on branch1
     1 files changed, 1 insertions(+), 0 deletions(-)

Lets modify the second line and add another line

    Starting file in _master_ branch. 
    First commit on branch1, modified.
    2nd commit on branch1.

and do another commit:

    $ git commit -am'2nd commit on branch1'
    [branch1 5dae0ab] 2nd commit on branch1
     1 files changed, 2 insertions(+), 1 deletions(-)

Lets see what the commit hashes are for reference, I've edited the
output to just the essentials:

    $ git log master..HEAD
    commit 5dae0ab43d8c4b87eb62f0b3253ac58477b046dc
        2nd commit on branch1
    commit 36a404f968a74302cdca5ec8cc81aa078a237ade
        First commit on branch1

## Patch File

Lets look at what a patch file looks like now:

    git format-patch master --stdout > ~/Desktop/file.patch

    Subject: [PATCH 1/2] First commit on branch1
     testBranch.mmd |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
     ---
     Starting file in _master_ branch.
    +First commit on branch1.

    Subject: [PATCH 2/2] 2nd commit on branch1
     testBranch.mmd |    3 ++-
     1 files changed, 2 insertions(+), 1 deletions(-)
     ---
     Starting file in _master_ branch.
    -First commit on branch1.
    +First commit on branch1, modified.
    +2nd commit on branch1.

## Squash/Rebase

Now this is the important point to remember.  This is an ugly patch
file.  A patch file should squash all the commits into a single
commit.  So lets do that.

    git rebase -i HEAD~2

This will pop open your editor with the following in it:

    pick 36a404f First commit on branch1
    pick 5dae0ab 2nd commit on branch1

Change this to:

    pick 36a404f First commit on branch1
    s 5dae0ab 2nd commit on branch1

Save and exit your editor, this will pop open another editor with the
following contents (edited slightly):

    # This is a combination of 2 commits.
    # The first commit's message is:
    First commit on branch1
    # This is the 2nd commit message:
    2nd commit on branch1

You can simply just leave this as is, and exit your editor to finish
the process.  You'll see the following output:

    [detached HEAD db947ce] First commit on branch1
     1 files changed, 2 insertions(+), 0 deletions(-)
    Successfully rebased and updated refs/heads/branch1.

Now lets look at the log history (slightly edited):

    $ git log master..HEAD
    commit db947ce2b427a241034057faf07f7fed8f3e5f3c
        First commit on branch1
        2nd commit on branch1

Lets see what the patch file looks like now too:

    Subject: [PATCH] First commit on branch1
    2nd commit on branch1
     testBranch.mmd |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
     ---
     Starting file in _master_ branch.
    +First commit on branch1, modified.
    +2nd commit on branch1.

This is 8 lines long instead of 14, and this is just for a trivial
edit, it just gets worse the more commits you have!

Now often, master would have moved forward on its own, so lets do just
that now.  Switch back to master branch.

    $ git checkout master
    Switched to branch 'master'



Now lets switch back to master:

    $ git checkout master

Insert a line at the top of the file:

    Came back to master and change original file.
    Starting file in _master_ branch. 

and commit the change:

    $ git commit -am'moving master forward 1'

then switch back to `branch1`, and lets look at what a patch file
looks like.

    $ git format-patch master --stdout > ~/Desktop/file.patch

    Subject: [PATCH] First commit on branch1
    2nd commit on branch1
     testBranch.mmd |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
    diff --git a/testBranch.mmd b/testBranch.mmd
    @@ -1 +1,3 @@
     Starting file in _master_ branch.
    +First commit on branch1, modified.
    +2nd commit on branch1.

So this is really just a patch of whats on `branch1` compared to where
it branched from `master`, NOT where `master` is at the moment.  So at
some point you need to bring your branch back to master, but now our
patch file is only going to help with where we branched from.  What we
want to always do is have our branch be able to patch where `master`
is now, not where it was.  So what we need to do is `rebase` our
branch over where master is now, and we can do that with the following
command, while on our branch:

    $ git rebase master
    First, rewinding head to replay your work on top of it...
    Applying: First commit on branch1
    Using index info to reconstruct a base tree...
    Falling back to patching base and 3-way merge...
    Auto-merging testBranch.mmd

So lets see what a patch file looks like now:

    @@ -1,2 +1,4 @@
     Came back to master and change original file.
     Starting file in _master_ branch.
    +First commit on branch1, modified.
    +2nd commit on branch1.
    -- 

As we can see, now we have that first line from the latest, moved
forward `master`.  Now when we supply the patch file to the *owner* of
the master branch, they'll be able to trivially merge your changes
onto the latest master.

## When rebasing fails

Sometimes you'll have a conflicting edit on your branch with something
that happened on master...lets simulate that now.

