# Reference

[GNU Emacs Manuals Online](http://www.gnu.org/software/emacs/manual/)

# Files

| Key Stroke | Effect                           |
| ---------- | -------------------------------- |
C-x C-f      | Open a new file
C-x s        | Save buffer(s)
C-x C-w      | Save As
C-x C-c      | Close emacs
C-x C-r      | Open file read only
C-x C-c      | Exit Emacs

# Navigation, Search & Replace

| Key Stroke        | Effect                           |
| ----------------- | -------------------------------- |
A->                 | Go to the beginning of the file
A-<                 | Go to the end of the file
A-g A-g             | Goto line #
A-(L/R) arrows      | Move word forward/backwards
A-f, A-b            | Move word forward/backwards
C-s                 | Incremental Search Forward
C-A-s               | Regular Expression incremental search
C-r                 | Incremental Search Backwards
A-%                 | Replace
A-x                 | query-replace-regexp Regex Replace
C-q C-j             | Keystroke for Carriage Return
C-q                 | Keystroke for space character
C-x (, C-x ), C-x e | Start, stop, playback macro
C-u 25 C-x e        | Replay macro 25 times

# Special Characters

| Name             | ASCII Code | string notation | Caret Notation | Input method                  |
| ---------------- | ---------- | --------------- | -------------- | ------------                  |
| horizontal tab   | 9          | \t              | I              | Ctrl+q Ctrl+i or Ctrl+q Tab   |
| line feed        | 10         | \n              | J              | Ctrl+q Ctrl+j                 |
| carriage return  | 13         | \r              | M              | Ctrl+q Ctrl+m or Ctrl+q Enter | 

# Buffers, Regions, & Windows

| Key Stroke          | Effect                           |
| ------------------- | -------------------------------- |
C-x 1                 | Unsplit window (keep this)
C-x 0                 | Unsplit window (keep others)
C-x 2                 | Split window horizontal
C-x 3                 | Split window vertical
C-x o                 | Move to the next window
C-x 1                 | Collapse other window
C-x 0                 | Collapse this window
C-x b                 | Load previous buffer
C-x C-b               | List all buffers. e to edit buffer
C-x k                 | Close buffer
C-x C-v Ret           | Reload buffer from file system
C-x b **scratch** RET | re-open scratch buffer
d                     | In buffer list, mark buffer for deletion, happens when hit x
A-^                   | Join this line to previous and fix up whitespace at join. If there is a fill prefix, delete it from the beginning of this line.

# Edit, Selection, Cut & Paste

| Key Stroke                 | Effect                           |
| ----------                 | -------------------------------- |
C-x u                        | Undo
A-q                          | Reformat Paragraph, take first line to 0 indent, then A-q, rest of paragraph is now 0 indent
C-A-\                        | Auto indent selected region
A-^                          | Remove indentation, brings current line up one
C-c C-c, M-x comment-region  | Comment out a marked region
C-u C-c C-c                  | Un-comment out the marked region
C-x h                        | Select wHole buffer
C-x 0                        | Delete the current window
A-w                          | Copy
C-w                          | Cut
C-y, Esc-y                   | Yank (paste), successive Esc-y get clipboard history
A-x cua-mode                 | Column Edit, C-Ret. begin selection

 In sgml-mode, a built-in pretty printing function called
(sgml-pretty-print ...)

# Keymaps & Function bindings

| Command         | Meaning                           |
| ----------      | -------------------------------- |
A-x describe-key  | and hit the key (or key combination) in question. This will reveal the name of the key as well as the function it is currently bound to.
C-h f             | Display documentation on the Lisp function named function (describe-function). Since commands are Lisp functions, a command name may be used.

# Exuberant ctags

go to the root of your source and enter:

```bash
ctags -Re
```

# Diff

-   [Reference](http://www.gnu.org/software/emacs/manual/html_node/emacs/Diff-Mode.html)

| Command  | Meaning                           |
| -------- | -------------------------------- |
C-c C-n    | Restrict the view to the current hunk (diff-restrict-view). See Narrowing. With a prefix argument of C-u, restrict the view to the current file of a multiple-file patch. 
C-x n w    | To widen again
A-n        | Move to the next hunk-start (diff-hunk-next).
A-p        | Move to the previous hunk-start (diff-hunk-prev).

# Latex

| Key Stroke  | Effect                           |
| ----------  | -------------------------------- |
C-c C-c       | to compile to **.dvi/**.pdf, again to view
C-c C-t C-p   | to toggle into PDF mode.
C-c =         | show TOC

# Programming

# Cheatsheet

| Key Stroke            | Effect                           |
| ----------            | -------------------------------- |
C-h v < variable-name > | display the contents of a variable
C-x C-e                 | evaluate an expression: position the cursor after a list and type

# Variables

| Variable | Definition |
| -------- | ---------- |
load-path  | The variable load-path lists all the directories where Emacs should look for Elisp files.

[Reference](http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html)

# Overview

Put your code into `*.el` files. Then put `*.el` into a directory on
your load-path, `/usr/local/share/emacs/site-lisp` or
`/usr/share/emacs/site-lisp/`, are reasonable locations. Then you can
put a line like the following into your .emacs file:

    (require 'textile-mode)

Put following into .emacs file, so you can reload your .emacs file
without closing and reopenning emacs.

    ;; Reload .emacs file by typing: A-x reload.
    (defun reload () "Reloads .emacs interactively."
    (interactive)
    (load "~/.emacs"))

# To create a function

A function definition has up to five parts following the word
defun:

-   The name of the symbol to which the function definition should
    be attached.
-   A list of the arguments that will be passed to the function. If
    no arguments will be passed to the function, this is an empty list,
    ().
-   Documentation describing the function. (Technically optional,
    but strongly recommended.)
-   Optionally, an expression to make the function interactive so
    you can use it by typing M-x and then the name of the function; or
    by typing an appropriate key or keychord.
-   The code that instructs the computer what to do: the body of
    the function definition.

It is helpful to think of the five parts of a function definition
as being organized in a template, with slots for each part:

    (defun function-name (arguments...)
      "optional-documentation..."
      (interactive argument-passing-info)     ; optional
      body...)

As an example, here is the code for a function that multiplies its
argument by 7. (This example is not interactive. See Making a
Function Interactive, for that information.)

    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))

# Install the function

Install the function by putting the cursor at the end of the
function and typing C-x C-e. This will install the function for the
life of your current emacs session. To install more permanently put
it in your ~/.emacs file.

To make the above function interactive do:

    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "The result is %d" (* 7 number)))

Invoke with `C-u` some number `A-x multiply-by-seven`.

# Installing *.el files

## One time

Ensure you have the following in your ~/.emacs file:

    (add-to-list 'load-path "~/projects/elisp")

## For each new *.el file

Ensure you have the following in your ~/.emacs file:

    (require 'foo)

where foo means foo.el

And put your foo.el file in: `~/projects/elisp`

# Reference

    C-SP     set-mark-command         C-q      quoted-insert
    C-a      beginning-of-line       C-r      isearch-backward
    C-b      backward-char           C-s      isearch-forward
    C-c      exit-recursive-edit         C-t      transpose-chars
    C-d      delete-char             C-u      universal-argument
    C-e      end-of-line             C-v      scroll-up
    C-f      forward-char            C-w      kill-region
    C-h      help-command            C-x      Control-X-prefix
    TAB      indent-for-tab-command      C-y      yank
    LFD      newline-and-indent      C-z      suspend-emacs
    C-k      kill-line           ESC      ESC-prefix
    C-l      recenter            C-]      abort-recursive-edit
    RET      newline             C-_      undo
    C-n      next-line           SPC .. ~        self-insert-command
    C-o      open-line           DEL      delete-backward-char
    C-p      previous-line
    
    C-h v    describe-variable       C-h d    describe-function
    C-h w    where-is            C-h k    describe-key
    C-h t    help-with-tutorial      C-h c    describe-key-briefly
    C-h s    describe-syntax         C-h b    describe-bindings
    C-h n    view-emacs-news         C-h a    command-apropos
    C-h C-n  view-emacs-news         C-h C-d  describe-distribution
    C-h m    describe-mode           C-h C-c  describe-copying
    C-h l    view-lossage            C-h ?    help-for-help
    C-h i    info                C-h C-h  help-for-help
    C-h f    describe-function
    
    C-x C-a  add-mode-abbrev         C-x 5    split-window-horizontally
    C-x C-b  list-buffers            C-x ;    set-comment-column
    C-x C-c  save-buffers-kill-emacs     C-x <    scroll-left
    C-x C-d  list-directory          C-x =    what-cursor-position
    C-x C-e  eval-last-sexp          C-x >    scroll-right
    C-x C-f  find-file           C-x [    backward-page
    C-x C-h  inverse-add-mode-abbrev     C-x ]    forward-page
    C-x TAB  indent-rigidly          C-x ^    enlarge-window
    C-x C-l  downcase-region         C-x `    next-error
    C-x C-n  set-goal-column         C-x a    append-to-buffer
    C-x C-o  delete-blank-lines      C-x b    switch-to-buffer
    C-x C-p  mark-page           C-x d    dired
    C-x C-q  toggle-read-only        C-x e    call-last-kbd-macro
    C-x C-r  find-file-read-only         C-x f    set-fill-column
    C-x C-s  save-buffer             C-x g    insert-register
    C-x C-t  transpose-lines         C-x h    mark-whole-buffer
    C-x C-u  upcase-region           C-x i    insert-file
    C-x C-v  find-alternate-file         C-x j    register-to-dot
    C-x C-w  write-file          C-x k    kill-buffer
    C-x C-x  exchange-dot-and-mark       C-x l    count-lines-page
    C-x C-z  suspend-emacs           C-x m    mail
    C-x ESC  repeat-complex-command      C-x n    narrow-to-region
    C-x $    set-selective-display       C-x o    other-window
    C-x (    start-kbd-macro         C-x p    narrow-to-page
    C-x )    end-kbd-macro           C-x q    kbd-macro-query
    C-x +    add-global-abbrev       C-x r    copy-rectangle-to-register
    C-x -    inverse-add-global-abbrev   C-x s    save-some-buffers
    C-x .    set-fill-prefix         C-x u    advertised-undo
    C-x /    dot-to-register         C-x w    widen
    C-x 0    delete-window           C-x x    copy-to-register
    C-x 1    delete-other-windows        C-x {    shrink-window-horizontally
    C-x 2    split-window-vertically     C-x }    enlarge-window-horizontally
    C-x 4    ctl-x-4-prefix          C-x DEL  backward-kill-sentence
    
    Alt C-SP mark-sexp           Alt =    count-lines-region
    Alt C-a  beginning-of-defun      Alt >    end-of-buffer
    Alt C-b  backward-sexp           Alt @    mark-word
    Alt C-c  exit-recursive-edit         Alt O    ??
    Alt C-d  down-list           Alt [    backward-paragraph
    Alt C-e  end-of-defun            Alt \    delete-horizontal-space
    Alt C-f  forward-sexp            Alt ]    forward-paragraph
    Alt C-h  mark-defun          Alt ^    delete-indentation
    Alt LFD  indent-new-comment-line     Alt a    backward-sentence
    Alt C-k  kill-sexp           Alt b    backward-word
    Alt C-n  forward-list            Alt c    capitalize-word
    Alt C-o  split-line          Alt d    kill-word
    Alt C-p  backward-list           Alt e    forward-sentence
    Alt C-s  isearch-forward-regexp      Alt f    forward-word
    Alt C-t  transpose-sexps         Alt g    fill-region
    Alt C-u  backward-up-list        Alt h    mark-paragraph
    Alt C-v  scroll-other-window         Alt i    tab-to-tab-stop
    Alt C-w  append-next-kill        Alt j    indent-new-comment-line
    Alt Alt  ??              Alt k    kill-sentence
    Alt C-\  indent-region           Alt l    downcase-word
    Alt SPC  just-one-space          Alt m    back-to-indentation
    Alt !    shell-command           Alt q    fill-paragraph
    Alt $    spell-word          Alt r    move-to-window-line
    Alt %    query-replace           Alt t    transpose-words
    Alt '    abbrev-prefix-mark      Alt u    upcase-word
    Alt (    insert-parentheses      Alt v    scroll-down
    Alt )    move-past-close-and-reindent    Alt w    copy-region-as-kill
    Alt ,    tags-loop-continue      Alt x    execute-extended-command
    Alt -    negative-argument       Alt y    yank-pop
    Alt .    find-tag            Alt z    zap-to-char
    Alt 0 .. Alt 9  digit-argument       Alt    |    shell-command-on-region
    Alt ;    indent-for-comment      Alt ~    not-modified
    Alt <    beginning-of-buffer      Alt DEL  backward-kill-word
    
    
    C-x 4 C-f   find-file-other-window   C-x 4 d  dired-other-window
    C-x 4 .     find-tag-other-window    C-x 4 f  find-file-other-window
    C-x 4 b     pop-to-buffer            C-x 4 m  mail-other-window


Dos to unix

    M-x set-buffer-file-coding-system RET undecided-unix

save the file (`C-x C-s`), or

    C-x RET f undecided-unix
    C-x C-f

Unix to dos

    M-x set-buffer-file-coding-system RET undecided-dos

save the file (`C-x C-s`), or

    C-x RET f undecided-dos
    C-x C-f


# References

* [An Introduction to Programming in Emacs Lisp](http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html)
* [GNU Emacs Lisp Reference Manual](http://www.delorie.com/gnu/docs/elisp-manual-21/elisp_toc.html)

# Notes

# Misc

To determine the value of a symbol do `C-x C-e` after the symbol.  Can
define a function like that too.

Items ending in p, such as zerop, stand for predicate and evaluate to
true of false.  So `(zerop 3) = false`, and `(zerop 0) = true`.

# set setq

The `setq` function sets the value of its first argument to the value
of the second argument. The first argument is automatically quoted by
`setq`. It does the same for succeeding pairs of arguments. Another
function, `set`, takes only two arguments and evaluates both of them
before setting the value returned by its first argument to the value
returned by its second argument.

# Functions

| Point                 | Explanation                      |
| --------------------- | -------------------------------- |
`C-h f [function-name]` | You can get help for a command by typing
`C-h w [function-name]` | where the key is, not the full documentation. 
`M-x describe-function` | Location of function definition
`M-.` aka `find-tag`    | see a function in its original source file

* The prompt for describe-function will offer you the symbol under or preceding
the cursor
* Put point into the name of the file that contains the function and press the RET
key. In this case, RET means push-button rather than ‘return’ or ‘enter’. Emacs
will take you directly to the function definition.

To create a tags-table from source code see: [^An Introduction to
Programming in Emacs Lisp. Page 44, Section 4.1 Finding More
Information]

# defun

    (defun function-name (arguments...)
     "optional-documentation..."
     (interactive argument-passing-info) ; optional
     body...)

    (defun multiply-by-seven (number)
     "Multiply NUMBER by seven."
     (* 7 number))
   
The argument list is followed by the documentation string that
describes the function. This is what you see when you type `C-h f` and
the name of a function.

    (defun multiply-by-seven (number) ; Interactive version.
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))

## interactive

In this function, the expression, (interactive "p"), is a list of two
elements.  The `p` tells Emacs to pass the prefix argument to the
function and use its value for the argument of the function.

Then, you can use this code by typing `C-u` and a number and then
typing `M-x multiply-by-seven` and pressing RET. The phrase `The
result is ...` followed by the product will appear in the echo area.

    (defun simplified-beginning-of-buffer ()
    "Move point to the beginning of the buffer;
    leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))

The interactive expression tells Emacs that the function is intended to be used
interactively. In this example, interactive does not have an argument because
simplified-beginning-of-buffer does not require one.

# if 

    (if (= 22 emacs-major-version)
      (message "This is version 22 Emacs")    
      (message "This is not version 22 Emacs"))

# let, let*

let is used to attach or bind a symbol to a value in such a way that
the Lisp interpreter will not confuse the variable with a variable of
the same name that is not part of the function.

Another way to think about let is that it is like a `setq` that is
temporary and local.

    (let ((variable value)
      (variable value)
       ...)
       body...)

    (let ((zebra ’stripes)
          (tiger ’fierce))
          (message "One kind of animal has %s and another is %s."
    zebra tiger))

    (if (> 5 4)
        (message "5 is greater than 4!"))

The `let*` function is different. It has a ‘*’ in its name. It enables
Emacs to set each variable in its varlist in sequence, one after
another.

Its critical feature is that variables later in the varlist can make
use of the values to which Emacs set variables earlier in the varlist.

# Debugger

As with the other times we entered the debugger, you can quit by
typing q in the ‘*Backtrace*’ buffer.

# Keymaps & Function bindings

| Command         | Key Binding                      |
| --------------- | -------------------------------- |
describe-key      | C-h k




A-x describe-key  | and hit the key (or key combination) in question. This will reveal the name of the key as well as the function it is currently bound to.
C-h f             | Display documentation on the Lisp function named function (describe-function). Since commands are Lisp functions, a command name may be used.

```
(global-set-key (kbd "C-.") 'scroll-up
;; Translate the problematic keys to the function key Hyper, 
;; then bind this to the desired ctrl-i behavior
(keyboard-translate ?\C-i ?\H-i)
(global-set-key [?\H-i] 'scroll-down)
```

| Point                 | Explanation                      |
| --------------------- | -------------------------------- |
C-h f [function-name]   | You can get help for a command by typing
C-h k [key-sequence]    | To get the command that would run
C-h w [function-name]   | where the key is, not the full documentation. 
C-h c [key sequence]    | what function is bound to a key sequence




# File Associations

Associate *.mmd with markdown-mode:

    (setq auto-mode-alist (cons '("\\.mmd$" . markdown-mode) auto-mode-alist))

basically there is an alist (associative list / hashtable) called
auto-mode-alist.  That points extension -> to mode.  Extension looks
like it's a regular expression.

cons is a function that appends an element to a list

setq means set quoted (which quotes auto-mode-list for you), otherwise
instead of assigning to the symbol auto-mode-alist, you will assign to
the results of evaluating that symbol...not what you want ;)



# cons cell, car, cdr, cons

A cons cell is an object that consists of two slots, called the car
slot and the cdr slot. Each slot can hold or refer to any Lisp
object. We also say that “the car of this cons cell is” whatever
object its car slot currently holds, and likewise for the cdr.

_A note to C programmers: in Lisp, we do not distinguish between
“holding” a value and “pointing to” the value, because pointers in
Lisp are implicit._

A list is a series of cons cells, linked together
so that the cdr slot of each cons cell holds either the next cons cell
or the empty list. The empty list is actually the symbol nil. See
Lists, for functions that work on lists. Because most cons cells are
used as part of lists, the phrase list structure has come to refer to
any structure made out of cons cells.

Because cons cells are so central to Lisp, we also have a word for “an
object which is not a cons cell.” These objects are called atoms.

# car

The car of a list is, quite simply, the first item in the list. Thus
the car of the list (rose violet daisy buttercup) is rose.

    (car '(rose violet daisy buttercup))

After evaluating the expression, `rose` will appear in the echo area.

# cdr

The cdr of a list is the rest of the list, that is, the cdr function
returns the part of the list that follows the first item. Thus, while
the car of the list '(rose violet daisy buttercup) is rose, the rest
of the list, the value returned by the cdr function, is (violet daisy
buttercup).

        (cdr '(rose violet daisy buttercup))

When you evaluate this, (violet daisy buttercup) will appear in the
echo area.

# cons

We often say that `cons puts a new element at the beginning of a list;
it attaches or pushes elements onto the list', but this phrasing can
be misleading, since cons does not change an existing list, but
creates a new one.

The cons function constructs lists; it is the inverse of car and
cdr. For example, cons can be used to make a four element list from
the three element list, (fir oak maple):

     (cons 'pine '(fir oak maple))

After evaluating this list, you will see

     (pine fir oak maple)

# Comparison Operators

# Adventures in eLisp

So lately I'm doing a lot of documentation and I've chosen to do it in
the multi-markdown language.  Since my documentation is always about
technology, I have a lot of code snippets that must be indented 4
spaces or a tab.  Also, originally, I had `fill-paragraph` turned on
which auto-wrapped lines that extended beyond `fill-column` in width.
That was great and desireable for text like this, but absolutely
undersirable with code fragments.

So my goal is to modify the `fill-paragraph` function so that it works
only when the text is not indented by 4 spaces.  I asked the question
on stackoverflow, and got the following 2 tips:

> You are going to need `fill-paragraph`, `if`, probably `progn`,
  probably `string=`, `save-excursion`, `forward-paragraph`,
  `backward-paragraph` and perhaps a few more. All of these can be
  read up if you do `M-x describe-function` and supply it the name.

> Do you know about `advice`

So first off lets have a look at `fill-paragraph` to see if we can understand how it works

* `C-h f fill-paragraph` will bring up it's documentation.  

So what I quickly realize is this is NOT bringing up the source for
the function, just it's documentation.  NOT what I want!

So I happened upon 

> look at the source (using `M-x find-function`)

Which flashes: 

    find-library-name: Can't find library/usr/share/emacs/23.1/lisp/textmodes/fill.el

in the minibuffer or status line at the bottom of the screen.  Trying
to highlight it is hopeless as it disappears quickly.  Just open the
`*Messages*` buffer and you can cut and paste any messages that were
flashed in the minibuffer.

So I'll do a find in my filesystem to see if **I** can find the file!
`C-x m` brings up an `*eshell*` on my system, which is just a terminal
window.

So I finally downloaded the source for emacs which contains a folder
called lisp and I found fill.el in there!

> Also, describe-function will tell you the location of the function definition.

`M-x describe-function` | Location of function definition
`M-.` aka `find-tag`    | see a function in its original source file
`C-x ESC ESC`           | lookup Emacs code, to repeat last command
`C-h f`                 | describe-function
`C-h v`                 | describe-variable
`C-h k`                 | which commands you are executing when you use keys

scroll-up

# Exercises

# Extend save-buffer function

I want everytime I save my buffer for a shell command to also run.

* Determine what is the save function

We can know what function is executed by a given set of keys by typing
`C-h k` before the key sequence.  Since we want to determine what is
the save command we do the previous before `C-x C-s`.

The result is the `save-buffer` command.

Now one strategy would be to create a new function that first calls
the save function then asynchronously (yes another requirement)
launches our external shell command and returns.  Then rebinding this
function to `C-x C-s`.  So lets learn how to get to the shell from
within emacs.

Hints: maybe use a subprocess.

`A-x shell` - start a shell

inferior shell

noninteractive shell

comint-send-input


compile

(compile COMMAND &optional COMINT)

Compile the program including the current buffer.  Default: run `make'.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer `*compilation*'.

so this looks good.  so i defined the function:

```
(defun save-buffer-run-shell-command ()
  "This function saves the current buffer and then runs the command 'pub' 
asynchronously."
  (save-buffer)
  (compile "pub"))
```

But when I ran it I go the error message:

    /bin/bash: pub: command not found

So I know my path must be updated to include the folder where pub is
defined: `~/scripts`.

The variable `initial-environment`, had a value for `PATH` in it with
the contents:

    /home/fenton/bin
    /usr/local/sbin
    /usr/local/bin
    /usr/sbin
    /usr/bin
    /sbin
    /bin
    /usr/games

No `/home/fenton/scripts` there!!!  So lets see if we can add/modify
the environment somehow...  Maybe use the functions `setenv` and
`getenv`.  Lets try the following:

Emacs, since it isn't started from a shell, doesn't get all the
settings specified in the .bashrc file.