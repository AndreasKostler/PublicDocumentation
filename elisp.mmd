To determine the value of a symbol do `C-x C-e` after the symbol.  Can
define a function like that too.

Items ending in p, such as zerop, stand for predicate and evaluate to
true of false.  So `(zerop 3) = false`, and `(zerop 0) = true`.

## set setq

The `setq` function sets the value of its first argument to the value
of the second argument. The first argument is automatically quoted by
`setq`. It does the same for succeeding pairs of arguments. Another
function, `set`, takes only two arguments and evaluates both of them
before setting the value returned by its first argument to the value
returned by its second argument.

# Functions

| Point                 | Explanation                      |
| --------------------- | -------------------------------- |
`C-h f <function-name>` | You can get help for a command by typing
`C-h w <function-name>` | where the key is, not the full documentation. 
`M-x describe-function` | Location of function definition
`M-.` aka `find-tag`    | see a function in its original source file

* The prompt for describe-function will offer you the symbol under or preceding
the cursor
* Put point into the name of the file that contains the function and press the RET
key. In this case, RET means push-button rather than ‘return’ or ‘enter’. Emacs
will take you directly to the function definition.

To create a tags-table from source code see: [^An Introduction to Programming in Emacs Lisp. Page 44, Section 4.1 Finding More Information]

## defun

    (defun function-name (arguments...)
     "optional-documentation..."
     (interactive argument-passing-info) ; optional
     body...)

    (defun multiply-by-seven (number)
     "Multiply NUMBER by seven."
     (* 7 number))
   
The argument list is followed by the documentation string that
describes the function. This is what you see when you type `C-h f` and
the name of a function.

    (defun multiply-by-seven (number) ; Interactive version.
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))

### interactive

In this function, the expression, (interactive "p"), is a list of two
elements.  The `p` tells Emacs to pass the prefix argument to the
function and use its value for the argument of the function.

Then, you can use this code by typing `C-u` and a number and then
typing `M-x multiply-by-seven` and pressing RET. The phrase `The
result is ...` followed by the product will appear in the echo area.

    (defun simplified-beginning-of-buffer ()
    "Move point to the beginning of the buffer;
    leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))

The interactive expression tells Emacs that the function is intended to be used
interactively. In this example, interactive does not have an argument because
simplified-beginning-of-buffer does not require one.

## if 

    (if (= 22 emacs-major-version)
      (message "This is version 22 Emacs")    
      (message "This is not version 22 Emacs"))

## let, let*

let is used to attach or bind a symbol to a value in such a way that
the Lisp interpreter will not confuse the variable with a variable of
the same name that is not part of the function.

Another way to think about let is that it is like a `setq` that is
temporary and local.

    (let ((variable value)
      (variable value)
       ...)
       body...)

    (let ((zebra ’stripes)
          (tiger ’fierce))
          (message "One kind of animal has %s and another is %s."
    zebra tiger))

    (if (> 5 4)
        (message "5 is greater than 4!"))

The `let*` function is different. It has a ‘*’ in its name. It enables
Emacs to set each variable in its varlist in sequence, one after
another.

Its critical feature is that variables later in the varlist can make
use of the values to which Emacs set variables earlier in the varlist.

## Keyboard shortcuts

Key binding, keymaps.

### Mode-specific keymaps

Mode-specific keymaps are bound using the define-key function,

    (define-key texinfo-mode-map "\C-c\C-cg" ’texinfo-insert-@group)

### Global

When you use `global-set-key` to set the keybinding for a single command
in all parts of Emacs, you are specifying the keybinding in
`current-global-map`.

Specific modes, such as C mode or Text mode, have their own keymaps;
the mode-specific keymaps override the global map that is shared by
all buffers.

    (global-set-key "\C-x\C-b" ’buffer-menu)

| Point                 | Explanation                      |
| --------------------- | -------------------------------- |
C-h f <function-name>   | You can get help for a command by typing
C-h k <key-sequence>    | To get the command that would run
C-h w <function-name>   | where the key is, not the full documentation. 
C-h c <key sequence>    | what function is bound to a key sequence

# File Associations

Associate *.mmd with markdown-mode:

    (setq auto-mode-alist (cons '("\\.mmd$" . markdown-mode) auto-mode-alist))

basically there is an alist (associative list / hashtable) called
auto-mode-alist.  That points extension -> to mode.  Extension looks
like it's a regular expression.

cons is a function that appends an element to a list

setq means set quoted (which quotes auto-mode-list for you), otherwise
instead of assigning to the symbol auto-mode-alist, you will assign to
the results of evaluating that symbol...not what you want ;)



# cons cell, car, cdr, cons

A cons cell is an object that consists of two slots, called the car
slot and the cdr slot. Each slot can hold or refer to any Lisp
object. We also say that “the car of this cons cell is” whatever
object its car slot currently holds, and likewise for the cdr.

_A note to C programmers: in Lisp, we do not distinguish between
“holding” a value and “pointing to” the value, because pointers in
Lisp are implicit._

A list is a series of cons cells, linked together
so that the cdr slot of each cons cell holds either the next cons cell
or the empty list. The empty list is actually the symbol nil. See
Lists, for functions that work on lists. Because most cons cells are
used as part of lists, the phrase list structure has come to refer to
any structure made out of cons cells.

Because cons cells are so central to Lisp, we also have a word for “an
object which is not a cons cell.” These objects are called atoms.

## car

The car of a list is, quite simply, the first item in the list. Thus
the car of the list (rose violet daisy buttercup) is rose.

    (car '(rose violet daisy buttercup))

After evaluating the expression, `rose` will appear in the echo area.

## cdr

The cdr of a list is the rest of the list, that is, the cdr function
returns the part of the list that follows the first item. Thus, while
the car of the list '(rose violet daisy buttercup) is rose, the rest
of the list, the value returned by the cdr function, is (violet daisy
buttercup).

        (cdr '(rose violet daisy buttercup))

When you evaluate this, (violet daisy buttercup) will appear in the
echo area.

## cons

We often say that `cons puts a new element at the beginning of a list;
it attaches or pushes elements onto the list', but this phrasing can
be misleading, since cons does not change an existing list, but
creates a new one.

The cons function constructs lists; it is the inverse of car and
cdr. For example, cons can be used to make a four element list from
the three element list, (fir oak maple):

     (cons 'pine '(fir oak maple))

After evaluating this list, you will see

     (pine fir oak maple)

# Comparison Operators




# Adventures in eLisp

So lately I'm doing a lot of documentation and I've chosen to do it in
the multi-markdown language.  Since my documentation is always about
technology, I have a lot of code snippets that must be indented 4
spaces or a tab.  Also, originally, I had `fill-paragraph` turned on
which auto-wrapped lines that extended beyond `fill-column` in width.
That was great and desireable for text like this, but absolutely
undersirable with code fragments.

So my goal is to modify the `fill-paragraph` function so that it works
only when the text is not indented by 4 spaces.  I asked the question
on stackoverflow, and got the following 2 tips:

> You are going to need `fill-paragraph`, `if`, probably `progn`,
  probably `string=`, `save-excursion`, `forward-paragraph`,
  `backward-paragraph` and perhaps a few more. All of these can be
  read up if you do `M-x describe-function` and supply it the name.

> Do you know about `advice`

So first off lets have a look at `fill-paragraph` to see if we can understand how it works

* `C-h f fill-paragraph` will bring up it's documentation.  

So what I quickly realize is this is NOT bringing up the source for
the function, just it's documentation.  NOT what I want!

So I happened upon 

> look at the source (using `M-x find-function`)

Which flashes: 

    find-library-name: Can't find library/usr/share/emacs/23.1/lisp/textmodes/fill.el

in the minibuffer or status line at the bottom of the screen.  Trying
to highlight it is hopeless as it disappears quickly.  Just open the
`*Messages*` buffer and you can cut and paste any messages that were
flashed in the minibuffer.

So I'll do a find in my filesystem to see if **I** can find the file!
`C-x m` brings up an `*eshell*` on my system, which is just a terminal
window.



> Also, describe-function will tell you the location of the function definition.


`M-x describe-function` | Location of function definition
`M-.` aka `find-tag`    | see a function in its original source file
